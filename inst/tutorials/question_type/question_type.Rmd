---
title: "Question Types in Learnr"
output:
  learnr::tutorial:
    allow_skip: true
runtime: shiny_prerendered
tutorial:
  # id: "com.example.tutorials.my-first-tutorial"
  version: 2.18
  # user_id: "barret"
---

```{r setup, include=FALSE}
library(learnr)
knitr::opts_chunk$set(echo = TRUE, highlight = TRUE)
```


## Basic Question Types

There are three basic types of quiz questions: radio button, checkbox, and text box.  Each one allows for one choice, multiple choices, and direct user input respectively.

### Question

[Explain general question setup]. [WIll make a sensible type between radio and checkbox].

```{r question}
question_radio(
  "Is this a good question?",
  answer("yes", correct = TRUE),
  answer("no", message = 'This is a good question.')
)
```



-------------------

### Radio

When wanting only one answer from a user, use a radio button question.  Even if multiple options are correct, the user is only able to pick a single value.

```{r radio}
question_radio(
  "Is this a good question?",
  answer("yes", correct = TRUE),
  answer("no", message = 'This is a good question.')
)
```

-------------------

### Checkbox

When wanting possibly **multiple** answers from a user, use a checkbox question.  All answers that are marked correct must be selected by the user to have the answer be correct.  A minimum of one correct answer is required.

```{r checkbox}
question_checkbox(
  "Select all the toppings that belong on a Margherita Pizza:",
  answer("tomato", correct = TRUE),
  answer("mozzarella", correct = TRUE),
  answer("basil", correct = TRUE),
  answer("extra virgin olive oil", correct = TRUE),
  answer("pepperoni", message = "Great topping! ... just not on a Margherita Pizza"),
  answer("onions"),
  answer("bacon"),
  answer("spinach"),
  random_answer_order = TRUE,
  allow_retry = TRUE,
  try_again = "Be sure to select all toppings!"
)
```

-------------------

### Text box

If you'd like users to submit open-ended answers, use a text box question.  Correct and incorrect answers will be matched exactly (including white space). A minimum of one correct answer is required.

Text value inputs are trimmed before they are compared to answers provided.

```{r text_box}
question_text(
  "Please enter the word 'C0rrect' below:",
  answer("correct", message = "Don't forget to capitalize"),
  answer("c0rrect", message = "Don't forget to capitalize"),
  answer("Correct", message = "Is it really an 'o'?"),
  answer("C0rrect", correct = TRUE),
  allow_retry = TRUE
)
```

-------------------

### Extra Arguments


* Messages
  * `correct`: Message to be displayed when a user gets a correct answer.
  * `incorrect`: Message to be displayed when a user gets an incorrect answer and is not able to try again.
  * `try_again`: Message to be displayed when a user gets an incorrect answer and has the ability to try again.
  * `message`: An additional, neutral message to be displayed along with the correct/incorrect message.
  * `post_message`: Additional message to display along with correct/incorrect feedback.  If `allow_retry` is `TRUE`, this message will only be displayed after the correct submission.  If `allow_retry` is `FALSE`, it will produce a second message alongside the `message` value.
* Question Setup
  * `allow_retry`: Boolean that determines if the user should get a second chance at submitting their answer
  * `random_answer_order`: Boolean that determines if the question answers are displayed in a random order
* Buttons
  * `submit_button`: Label of the submit button
  * `try_again_button`: Label of the submit button
* Extra
  * `options`: List of extra pieces of information to store.  For an example, `question_text` uses `options` to store the `trim` and `placeholder` values.

Example:

```{r options, echo = TRUE}
question(
  "How many options are set in this question?",
  answer("1", message = "Really?"),
  answer("2"),
  answer("3"),
  answer("10", correct = TRUE, message = "Custom message here."),
  type = "text", # radio
  correct = "Question is correct!",
  try_again = "Higher!",
  message = "Reminder to do something after answering the question...",
  post_message = "Message to be displayed after the correct answer is found",
  submit_button = "Submit Answer Here!",
  try_again_button = "Try Again Here!",
  allow_retry = TRUE,
  random_answer_order = TRUE,
  options = list(
    placeholder = "The answer is '10'"
  )
)
```

## Custom Question Types

[learnr can not make all question types.  To implement custom questions, ... ]

["learnr allows for custom questions". Sortable has done this...]

[[Move question_sortable from bottom to here.]]

```{r sortable_example, eval = FALSE}
question_sortable <- function(..., options = sortable_options()) {
  question(
    ...,
    type = "sortable",
    options = options
  )
}

question_sortable(
  ...
)
```


There are five methods used to define a custom question.  Each [s3 method](http://adv-r.had.co.nz/S3.html) should correspond to the `type = TYPE` supplied to the question.

* `question_ui_initialize.TYPE(question, value, ...)`
  * Determines how the question is initially displayed to the users. This should return an object that can be displayed using [`shiny::renderUI`](https://shiny.rstudio.com/reference/shiny/latest/renderUI.html).  This method will be re-executed if the question is attempted again.  The `value` will contain a known starting value for continuity between attempts.
* `question_ui_try_again.TYPE(question, value, ...)`
  * Determines how the question is displayed to the users after they answer the question incorrectly and are allowed multiple attempts. This function should return an object that can be displayed using [`shiny::renderUI`](https://shiny.rstudio.com/reference/shiny/latest/renderUI.html).  The `value` will contain the currently submitted answer.
* `question_ui_completed.TYPE(question, value, ...)`
  * Determines how the question is displayed after a correct answer or an incorrect answer that can not be attempted again.  This should return an object that can be displayed using [`shiny::renderUI`](https://shiny.rstudio.com/reference/shiny/latest/renderUI.html).
* `question_is_valid.TYPE(question, value, ...)`
  * This method should return a boolean that determines if the input answer is valid.  Depending on the value, this function enables and disables the submission button.
* `question_is_correct.TYPE(question, value, ...)`
  * This method should return a boolean that determines if the input answer is correct.  This function's return value should be the output of `learnr::correct`, `learnr::incorrect`, or `learnr::mark_as`.

If a vector is supplied to `type`, following S3 rules, methods will be dispatched starting with the first type value and ending with the last type value.

For example:

```{r custom_class}
ques <- question(
  "Custom Method",
  answer("answer", correct = TRUE),
  type = c("A", "B", "checkbox")
)
```

When the question, `ques`, above is initialized, `question_initialize_input` will dispatch on `question_initialize_input.A`, then `question_initialize_input.B`, and settle on the existing method of `question_initialize_input.checkbox` as `question_initialize_input.A` and `question_initialize_input.B` do not exist.  Supplying multiple type values allows for clean abstraction between objects that share common functionality.


### **sortable**

Sortable.js is a "JavaScript library for reorderable drag-and-drop lists."  Reorderable lists quickly exends to ranking questions.

[`sortable`](https://rstudio.github.io/sortable/) has [implemented](https://github.com/rstudio/sortable/blob/master/R/learnr.R) a `sortable_list` tutorial `question` using the four generic methods above.  In the code sections below, we will walk through each method and a final helper method to create `sortable` tutorial questions.

#### `question_initialize_input.sortable`

`question_initialize_input()` is called when the question is first initialized and after a user wants to try again.

The code below extracts the necessary information to create a Shiny UI object, using the the `question$ids$answer` value and labels from the first answer.  Using the `learnr::question` `options` parameter, we can pass options directly to the `sortable_list` function.

```{r sortable_init, eval = FALSE}
question_initialize_input.sortable <- function(question, answer_input, ...) {

  if (!is.null(answer_input)) {
    # if an answer exists already, it should be displayed as is
    labels <- answer_input
  } else {
    # get the first answer order
    labels <- question$answers[[1]]$option

    # if the question is to be displayed in random order, shuffle the options
    if (
      isTRUE(question$random_answer_order) # and we should randomize the order
    ) {
      labels <- sample(labels, length(labels))
    }
  }

  # return the sortable htmlwidget
  sortable_list(
    question$ids$answer,
    labels,
    options = question$options
  )
}
```

#### `question_completed_input.sortable`

`question_completed_input()` is called when the question is finished and can not be tried again.

The code below adds an extra `options` value to disable Sortable.js.  Like `question_initialize_input`, it also returns a Shiny UI object.

```{r sortable_complete, eval = FALSE}
question_completed_input.sortable <- function(question, answer_input, ...) {
  sortable_list(
    question$ids$answer,
    answer_input,
    options = modifyList(
      question$options,
      # forcefully add an extra option to disable sortable.js
      sortable_options(disabled = TRUE)
    )
  )
}
```



#### `question_is_valid.sortable`

`question_is_valid()` is called to determine if the submit button should be clickable.

The default value of `!is.null(answer_input)` will work for the `sortable` question.  Therefore, no implementation is needed.


#### `question_is_correct.sortable`

`question_is_correct()` is called to determine if the answer submitted is correct.  This method is required and it may be helpful to use the `options` supplied to a `question` to change how an answer is found to be correct.

Since sortable is comparing a character vector to possible answer character vectors, a quick `identical` check through each answer will be enough for this method.

The return value from `question_is_correct` should return output from `question_is_correct_value`.  This allows for extra messages to be displayed while determining if the answer is correct / incorrect.

```{r sortable_correct, eval = FALSE}
question_is_correct.sortable <- function(question, answer_input, ...) {
  # for each possible answer, check if it matches
  for (answer in question$answers) {
    if (identical(answer$option, answer_input)) {
      # if it matches, return the correct-ness and its message
      return(question_is_correct_value(answer$is_correct, answer$message))
    }
  }
  # no match found. not correct
  return(question_is_correct_value(FALSE, NULL))
}
```


#### `question_sortable`

This final method is a helper method used for a cohesive API.

There are few main advantages by wrapping a `sortable` `question` with `question_sortable`:

* options can be inforced specifically for a `sortable` `question`
* the specialized function can be found with auto complete inside an IDE
* and different default behavior can be enforced using the wrapper function.



```{r question_sortable, eval = FALSE}
question_sortable <- function(
  # all extra arguments are passed directly to learnr::question
  ...,
  # random_answer_order will be used. Allow for it to be auto completed
  random_answer_order = TRUE,
  # hint that options should be made from `sortable_options()`
  options = sortable_options()
) {
  learnr::question(
    ...,
    random_answer_order = random_answer_order,
    type = "sortable",
    options = options
  )
}
```
