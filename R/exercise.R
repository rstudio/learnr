
# run an exercise and return HTML UI
setup_exercise_handler <- function(exercise_rx, session) {

  # get the environment where shared setup and data is located. one environment up
  # includes all of the shiny housekeeping (e.g. inputs, output, etc.); two
  # environments up will be an empty environment
  # (https://github.com/rstudio/rmarkdown/blob/54bf8fc70122c6a435bba2ffcac8944d04498541/R/shiny_prerendered.R#L10)
  # that is parented by the shiny_prerendered server_envir (which has all of
  # the shared setup, data chunks executed).
  server_envir <- parent.env(parent.env(parent.frame()))

  # setup reactive values for return
  rv <- reactiveValues(triggered = 0, result = NULL)

  # observe input
  observeEvent(exercise_rx(), {
    # get exercise
    exercise <- exercise_rx()

    # short circuit for restore (we restore some outputs like errors so that
    # they are not re-executed when bringing the tutorial back up)
    if (exercise$restore) {
      object <- get_exercise_submission(session = session, label = exercise$label)
      if (!is.null(object) && !is.null(object$data$output)) {

        # get the output
        output <- object$data$output

        # ensure that html dependencies only reference package files
        dependencies <- htmltools::htmlDependencies(output)
        if (!is.null(dependencies))
          htmltools::htmlDependencies(output) <- filter_dependencies(dependencies)

        # assign to rv and return
        rv$result <- output
        return()
      }
    }

    # get timelimit option (either from chunk option or from global option)
    timelimit <- exercise$options$exercise.timelimit
    if (is.null(timelimit))
      timelimit <- getOption("tutorial.exercise.timelimit", default = 30)

    # get exercise evaluator factory function (allow replacement via global option)
    evaluator_factory <- getOption("tutorial.exercise.evaluator", default = NULL)
    if (is.null(evaluator_factory)) {
      remote_host <- getOption("tutorial.external.host", Sys.getenv("TUTORIAL_EXTERNAL_EVALUATOR_HOST", NA))
      if (!is.na(remote_host)){
        evaluator_factory <- external_evaluator(remote_host)
      } else if (!is_windows() && !is_macos())
        evaluator_factory <- forked_evaluator_factory
      else
        evaluator_factory <- inline_evaluator
    }

    # supplement the exercise with the global setup options
    # TODO: warn if falling back to the `setup` chunk with an out-of-process evaluator.
    exercise$global_setup <- get_global_setup()
    # retrieve exercise cache information:
    # - chunks (setup + exercise) for the exercise to be processed in `evaluate_exercise`
    # - checker code (check, code-check, error-check)
    # - solution
    # - engine
    exercise <- append(exercise, get_exercise_cache(exercise$label))
    # If there is no locally defined error check code, look for globally defined error check option
    exercise$error_check <- exercise$error_check %||% exercise$options$exercise.error.check.code
    if (!isTRUE(exercise$should_check)) {
      exercise$check <- NULL
      exercise$code_check <- NULL
      exercise$error_check <- NULL
    }
    # variable has now served its purpose so remove it
    exercise$should_check <- NULL

    # placeholder for current learnr version to deal with exercise structure differences
    # with other learnr versions
    exercise$version <- "1"

    # create a new environment parented by the global environment
    # transfer all of the objects in the server_envir (i.e. setup and data chunks)
    envir <- duplicate_env(server_envir, parent = globalenv())

    # create exercise evaluator
    evaluator <- evaluator_factory(evaluate_exercise(exercise, envir),
                                   timelimit, exercise, session)

    # Create exercise ID to map the associated events.
    ex_id <- random_id("lnr_ex")

    # fire event before computing
    event_trigger(
      session,
      "exercise_submitted",
      data = list(
        label   = exercise$label,
        id      = ex_id,
        code    = exercise$code,
        restore = exercise$restore
      )
    )

    start <- Sys.time()

    # start it
    evaluator$start()

    # poll for completion
    o <- observe({

      if (evaluator$completed()) {

        # get the result
        result <- evaluator$result()

        # fire event with evaluation result
        event_trigger(
          session,
          "exercise_result",
          data = list(
            label            = exercise$label,
            id               = ex_id,
            code             = exercise$code,
            output           = result$html_output,
            timeout_exceeded = result$timeout_exceeded,
            time_elapsed     = as.numeric(difftime(Sys.time(), start, units="secs")),
            error_message    = result$error_message,
            checked          = !is.null(exercise$code_check) || !is.null(exercise$check),
            feedback         = result$feedback
          )
        )

        # assign reactive result value
        rv$triggered <- isolate({ rv$triggered + 1})
        rv$result <- result$html_output

        # destroy the observer
        o$destroy()

      } else {
        invalidateLater(100, session)
      }
    })
  })

  # return reactive
  reactive({
    rv$triggered
    req(rv$result)
  })
}

# helper function that will upgrade a previous learnr exercise into new learnr exercise
# TODO: do the actual upgrade
upgrade_exercise <- function(exercise) {
  # if version doesn't exist we're at "0" (older learnr)
  if (is.null(exercise$version)) {
    exercise$version <- "0"
  }
  # for now, raise error when learnr version is not supported
  # else, return the exercise for the correct version, "1"
  switch(exercise$version,
         "0" = stop("Exercise version not supplied! Unable to upgrade exercise."),
         "1" = { exercise },
         stop("Exercise version unknown. Unable to upgrade exercise.")
  )
}

# evaluate an exercise and return a list containing output and dependencies
# @param evaluate_global_setup - If `FALSE`, will not evaluate the global setup
#   code. Instead, it just concatenates the exercise- specific setup code and
#   then the submitted exercise code itself into the resultant expression. If
#   `TRUE`, it will evaluate global exercise setup chunk
#   (`setup-global-exercise` or `setup`) prior to running the checker. Local
#   evaluators inherit an environment in which those setup chunks have already
#   been executed, so they'd typically use `FALSE`, the default. Remote
#   evaluators, if they choose to use this function, might want to include the
#   global setup.
evaluate_exercise <- function(exercise, envir, evaluate_global_setup = FALSE) {

  # for compatibility with previous learnr versions, we'll upgrade exercise (if possible)
  exercise <- upgrade_exercise(exercise)

  # return immediately and clear visible results
  # do not consider this an exercise submission
  if (!nzchar(str_trim(paste0(exercise$code, collapse = "\n")))) {
    # " " since html_output needs to pass a req()
    return(exercise_result(html_output = " "))
  }

  if (evaluate_global_setup) {
    eval(parse(text = exercise$global_setup), envir = envir)
  }

  envir_prep <- duplicate_env(envir)

  # Setup a temporary directory for rendering the exercise
  exercise_dir <- tempfile(pattern = "lnr-ex")
  dir.create(exercise_dir)
  on.exit(unlink(exercise_dir), add = TRUE)

  checker_feedback <- NULL
  # Run the checker pre-evaluation _if_ there is code checking to do
  if (length(exercise$code_check)) {
    checker_feedback <- try_checker(
      exercise, "exercise.checker",
      check_code = exercise$code_check,
      envir_result = NULL,
      evaluate_result = NULL,
      envir_prep = envir_prep,
      last_value = NULL,
      engine = exercise$engine
    )
    if (is_exercise_result(checker_feedback)) {
      return(checker_feedback)
    }
  }

  # Resolve knitr options for the exercise and setup chunks
  rmd_results <- withr::with_dir(exercise_dir, render_exercise(exercise, envir, envir_prep))

  if (is_exercise_result(rmd_results)) {
    return(rmd_results)
  }

  # Run the checker post-evaluation (for checking code results)
  if (length(exercise$check)) {
    checker_feedback <- try_checker(
      exercise, "exercise.checker",
      check_code = exercise$check,
      envir_result = envir,
      evaluate_result = rmd_results$evaluate_result,
      envir_prep = envir_prep,
      last_value = rmd_results$last_value,
      engine = exercise$engine
    )
  }

  # include any checker feedback with the exercise results

  exercise_result(
    feedback = checker_feedback$feedback,
    html_output = rmd_results$html_output,
    exercise = exercise
  )
}


try_checker <- function(exercise, name, check_code, envir_result,
                        evaluate_result, envir_prep, last_value,
                        engine) {
  checker_func <- tryCatch(
    get_checker_func(exercise, name, envir_prep),
    error = function(e) {
      message("Error occured while retrieving 'exercise.checker'. Error:\n", e)
      exercise_result_error(
        e$message,
        exercise = exercise
      )
    }
  )
  # If retrieving checker_func fails, return an error result
  if (is_error_result(checker_func)) {
    return(checker_func)
  }
  checker_args <- names(formals(checker_func))
  args <- list(
    label = exercise$label,
    user_code = exercise$code,
    solution_code = exercise$solution,
    check_code = check_code,
    envir_result = envir_result,
    evaluate_result = evaluate_result,
    envir_prep = envir_prep,
    last_value = last_value,
    engine = engine
  )
  # Throw better error messaging if the checker function signature is ill-defined
  missing_args <- setdiff(names(args), checker_args)
  if (length(missing_args) && !"..." %in% checker_args) {
    msg <- sprintf(
      "Either add ... or the following arguments to the '%s' function: '%s'",
      name, paste(missing_args, collapse = "', '")
    )
    message(msg)
    return(exercise_result_error(msg, exercise = exercise))
  }

  # Call the check function
  feedback <- tryCatch(
    do.call(checker_func, args),
    error = function(e) {
      msg <- paste("Error occurred while evaluating", sprintf("'%s'", name))
      message(msg, ": ", conditionMessage(e))
      exercise_result_error(msg, exercise = exercise)
    }
  )
  # If checker code fails, return an error result
  if (is_error_result(feedback)) {
    return(feedback)
  }
  # If checker doesn't return anything, there's no exercise result to return
  if (length(feedback)) {
    exercise_result(feedback, exercise = exercise)
  } else {
    feedback
  }
}

get_checker_func <- function(exercise, name, envir) {
  func <- exercise$options[[name]]
  # attempt to parse the exercise.checker and return the function
  # with envir attached to it.
  checker <- eval(parse(text = func), envir = envir)
  if (is.function(checker)) {
    environment(checker) <- envir
    return(checker)
  } else if(!is.null(checker)) {
    warning("Ignoring the ", name, " option since it isn't a function", call. = FALSE)
  }
  function(...) NULL
}

render_exercise <- function(exercise, envir, envir_prep) {
  # Make sure exercise (& setup) chunk options and code are prepped for rendering
  exercise <- prepare_exercise(exercise)
  # start constructing knitr_options for the output format
  knitr_options <- rmarkdown::knitr_options_html(
    fig_width = exercise$options$fig.width,
    fig_height = exercise$options$fig.height,
    fig_retina = exercise$options$fig.retina,
    keep_md = FALSE
  )
  # capture the last value and use a regular output handler for value
  # https://github.com/r-lib/evaluate/blob/e81ba2ba181827a86525767371e6dfdeb364c8b7/R/output.r#L54-L56
  # @param value Function to handle the values returned from evaluation. If it
  #   only has one argument, only visible values are handled; if it has more
  #   arguments, the second argument indicates whether the value is visible.
  last_value <- NULL
  last_value_is_visible <- TRUE
  evaluate_result <- NULL
  knitr_options$knit_hooks$evaluate <- function(
    code, envir, ..., output_handler # knitr's output_handler
  ) {
    has_visible_arg <- length(formals(output_handler$value)) > 1
    # wrap `output_handler$value` to be able to capture the `last_value`
    # while maintaining the original functionality of `output_handler$value`
    output_handler_value_fn <- output_handler$value
    output_handler$value <- function(x, visible) {
      last_value <<- x
      last_value_is_visible <<- visible

      if (has_visible_arg) {
        output_handler_value_fn(x, visible)
      } else {
        if (visible) {
          output_handler_value_fn(x)
        } else {
          invisible()
        }
      }
    }
    evaluate_result <<- evaluate::evaluate(
      code, envir, ...,
      output_handler = output_handler
    )
    evaluate_result
  }

  # Put the exercise in a minimal HTML doc
  output_format <- rmarkdown::output_format(
    knitr = knitr_options,
    pandoc = NULL,
    base_format = rmarkdown::html_fragment(
      df_print = exercise$options$exercise.df_print,
      pandoc_args = c("--metadata", "title=PREVIEW")
    )
  )
  rmd_src <- c(
    readLines(system.file("internals", "templates", "exercise-setup.Rmd", package = "learnr")),
    "", exercise_code_chunks(exercise)
  )
  rmd_file <- "exercise.Rmd"
  writeLines(rmd_src, con = rmd_file, useBytes = TRUE)

  # First, Rmd to markdown (and exit early if any error)
  output_file <- tryCatch({
    rmarkdown::render(
      input = rmd_file,
      output_format = output_format,
      envir = envir,
      clean = FALSE,
      quiet = TRUE,
      run_pandoc = FALSE
    )
  }, error = function(e) {
    msg <- conditionMessage(e)
    # make the time limit error message a bit more friendly
    pattern <- gettext("reached elapsed time limit", domain = "R")
    if (grepl(pattern, msg, fixed = TRUE)) {
      return(exercise_result_timeout(exercise = exercise))
    }
    if (length(exercise$error_check)) {
      # Run the condition through an error checker (the exercise could be to throw an error!)
      checker_feedback <- try_checker(
        exercise, "exercise.checker",
        check_code = exercise$error_check,
        envir_result = envir,
        evaluate_result = evaluate_result,
        envir_prep = envir_prep,
        last_value = e,
        engine = exercise$engine
      )
      if (is_exercise_result(checker_feedback)) {
        return(checker_feedback)
      }
    }
    exercise_result_error(msg, exercise = exercise)
  })

  if (is_exercise_result(output_file)) {
    return(output_file)
  }

  # Render markdown to HTML
  dependencies <- filter_dependencies(attr(output_file, "knit_meta"))
  output_file <- rmarkdown::render(
    input = output_file, output_format = output_format,
    envir = envir, quiet = TRUE, clean = FALSE
  )
  output <- readLines(output_file, warn = FALSE, encoding = "UTF-8")
  html_output <- htmltools::attachDependencies(
    htmltools::HTML(paste(output, collapse = "\n")),
    dependencies
  )

  if (!last_value_is_visible && isTRUE(exercise$options$exercise.warn_invisible)) {
    invisible_feedback <- list(
      message = "The submitted code didn't produce a visible value, so exercise checking may not work correctly.",
      type = "warning", correct = FALSE
    )

    html_output <- htmltools::tagList(
      feedback_as_html(invisible_feedback, exercise),
      html_output
    )
  }

  list(
    evaluate_result = evaluate_result,
    last_value = last_value,
    html_output = html_output
  )
}

exercise_code_chunks <- function(exercise) {
  vapply(exercise$chunks, function(x) {
    opts <- paste(names(x$opts), unname(x$opts), sep = "=")
    paste(
      sep = "\n",
      # we quote the label to ensure that it is treated as a label and not a symbol for instance
      sprintf("```{%s}", paste0(c(x$engine, dput_to_string(x$label), opts), collapse = ", ")),
      paste0(x$code, collapse = "\n"),
      "```"
    )
  }, character(1))
}


exercise_result_timeout <- function(exercise) {
  exercise_result_error(
    "Error: Your code ran longer than the permitted timelimit for this exercise.",
    timeout_exceeded = TRUE,
    exercise = exercise
  )
}

# @param timeout_exceeded represents whether or not the error was triggered
#   because the exercise exceeded the timeout. Use NA if unknown
exercise_result_error <- function(
  error_message,
  feedback = NULL,
  timeout_exceeded = NA,
  exercise = NULL
) {
  exercise_result(
    feedback = feedback,
    timeout_exceeded = timeout_exceeded,
    error_message = error_message,
    html_output = error_message_html(error_message, exercise),
    exercise = exercise
  )
}

exercise_result <- function(
  feedback = NULL,
  html_output = NULL,
  error_message = NULL,
  timeout_exceeded = FALSE,
  exercise = NULL
) {

  # When `exercise` is empty, we return a list of NULL
  # `exercise` is NULL when there was no code sent (i.e the
  # student hasn't entered any code)
  if (is.null(exercise)){
    return(
      structure(
        list(
          feedback = feedback,
          error_message = error_message,
          timeout_exceeded = timeout_exceeded,
          html_output = html_output
        ),
        class = "learnr_exercise_result"
      )
    )
  }

  feedback <- feedback_validated(feedback)
  feedback_html <- feedback_as_html(feedback, exercise)

  exercise.gradethis_feedback_show <- exercise$options$exercise.gradethis_feedback_show %||% TRUE
  exercise.gradethis_code_show <- exercise$options$exercise.gradethis_code_show %||% TRUE

  # The trainer want feedbacks and code (the default)
  if (
    exercise.gradethis_feedback_show &
    exercise.gradethis_code_show
  ){
    html_output <- switch(
      feedback$location %||% "append",
      append = {
        feedback_html$children <- list(
          feedback_html$children[[1]],
          html_output

        )
        feedback_html
      },
      prepend = {
        feedback_html$children <- list(
          html_output,
          feedback_html$children[[1]]
        )
        feedback_html
      },
      replace = feedback_html,
      stop("Feedback location of ", feedback$location, " not supported")
    )
  } else if (
    # The trainer want feedbacks only
    exercise.gradethis_feedback_show &
    ! exercise.gradethis_code_show
  ) {
    html_output <- feedback_html
  } else if (
    # The trainer wants code only
    ! exercise.gradethis_feedback_show &
    exercise.gradethis_code_show
  ) {
    html_output <- tags$div(
      html_output
    )
  } else if (
    # The trainer wants no feedback
    ! exercise.gradethis_feedback_show &
    ! exercise.gradethis_code_show
  ){
    # Not sure what to do there, (i.e the trainer want neither feedback nor code)
    html_output <- div(
      class = "alert alert-grey",
      role = "alert",
      "Code submitted"
    )
  }

  structure(
    list(
      feedback = feedback,
      error_message = error_message,
      timeout_exceeded = timeout_exceeded,
      html_output = html_output
    ),
    class = "learnr_exercise_result"
  )
}

is_exercise_result <- function(x) {
  inherits(x, "learnr_exercise_result")
}

is_error_result <- function(x) {
  is_exercise_result(x) && length(x$error_message)
}

filter_dependencies <- function(dependencies) {
  # purge dependencies that aren't in a package (to close off reading of
  # artibtary filesystem locations)
  Filter(x = dependencies, function(dependency) {
    if (!is.null(dependency$package)) {
      TRUE
    }
    else {
      ! is.null(tryCatch(
        rprojroot::find_root(rprojroot::is_r_package,
                             path = dependency$src$file),
        error = function(e) NULL
      ))
    }
  })
}


prepare_exercise <- function(exercise) {
  exercise$chunks <- lapply(exercise$chunks, function(chunk) {
    isExercise <- identical(chunk$label, exercise$label)
    chunk$opts <- merge_options(
      preserved_opts = chunk$opts,
      # don't include the exercise options in setup chunks
      inherited_opts = if (isExercise) exercise$options else list(),
      static_opts = if (isExercise) {
        list(
          eval = TRUE, echo = FALSE, tutorial = NULL,
          cache = FALSE, child = NULL
        )
      } else {
        # don't include results in setup chunks
        list(include = FALSE)
      }
    )
    # Move over user submission code to the pre-rendered chunk object
    if (isExercise) {
      chunk$code <- exercise$code
    }
    chunk
  })
  exercise
}

# `preserved_opts` are options that user supplied in Rmd
# `inherited_opts` are exercise options
# `static_opts` are list of manually set options, e.g. list(include=FALSE) for setup chunks.
merge_options <- function(preserved_opts, inherited_opts, static_opts = list()) {
  # note: we quote each option's value if its type is a character, else return as is
  # to prevent rmd render problems (for e.g. fig.keep="high" instead of fig.keep=high)
  static_opts <- lapply(static_opts, dput_to_string)
  inherited_opts <- lapply(inherited_opts, dput_to_string)
  # get all the unique names of the options
  option_names <- unique(c(names(preserved_opts), names(inherited_opts), names(static_opts)))
  opts <- lapply(option_names, function(option_name) {
    # first we want manually set options, then user's, then exercise
    static_opts[[option_name]]  %||%
      preserved_opts[[option_name]] %||%
      inherited_opts[[option_name]]
  })
  # since we manually grab the names, set the names to opts
  names(opts) <- option_names
  # filter out options we don't need for the exercise.Rmd
  opts <- opts[!(names(opts) %in% c("label", "engine", "code"))]
  opts[!grepl("^exercise", names(opts))]
}
